using System.Globalization;
using System.Text;
using System.Linq;
using System.Xml.Linq;
using SixtenLabs.Spawn.Utility;
using System;
using System.Collections.Generic;
using SixtenLabs.Spawn.Vulkan.Model;
using System.Text.RegularExpressions;

namespace SixtenLabs.Spawn.Vulkan
{
	public class EnumCreator : BaseCreator
	{ 
		public EnumCreator(ICodeGenerator generator, IVulkanSpec vulkanSpec)
			: base(generator, vulkanSpec, 20, "Enum", "Enum")
		{
		}
		
		private bool TypeBitmaskFilter(XElement xtype)
		{
			var xcat = xtype.Attribute("category");

			return xcat != null && xcat.Value == "bitmask";
		}

		private EnumDefinition GenerateEmptyBitmask(string name)
		{
			var vkEnum = new EnumDefinition
			{
				Name = name.GetEnumName(),
				HasFlags = true
			};

			vkEnum.Comments.Add($"Generated by Spawn: {DateTime.Now}");

			var vkEnumValue = new EnumMemberDefinition
			{
				Name = "VK_NONE",
				Value = "0",
				Comment = "Autogenerated by Tanaga"
			};

			return vkEnum;
		}

		private EnumDefinition ReadEnum(XElement xenums)
		{
			if (xenums.Name != "enums")
			{
				throw new ArgumentException("Not an enum colletion", nameof(xenums));
			}

			var vkEnum = new EnumDefinition();

			var xattributes = xenums.Attributes();

			if (xattributes.Count() != 0)
			{
				foreach (var xattrib in xattributes)
				{
					switch (xattrib.Name.ToString())
					{
						case "name":
							vkEnum.Name = xattrib.Value.GetEnumName();
							break;
						case "type":
							vkEnum.HasFlags = xattrib.Value == "bitmask";
							break;
						case "expand":
							vkEnum.Expand = xattrib.Value;
							break;
						case "namespace":
							vkEnum.Namespace = xattrib.Value;
							break;
						case "comment":
							vkEnum.Comments.Add(xattrib.Value);
							break;
						default: throw new NotImplementedException(xattrib.Name.ToString());
					}
				}
			}

			if (string.IsNullOrEmpty(vkEnum.Name))
				throw new InvalidOperationException("Enum collection does not have proper `<name>` element");

			// note: there are also `unused` blocks that are not currently used...
			var enumValues = xenums.Elements("enum").Select(ReadEnumValue);
			vkEnum.AddEnumMembers(enumValues);

			return vkEnum;
		}

		private EnumMemberDefinition ReadEnumValue(XElement xenum)
		{
			if (xenum.Name != "enum")
				throw new ArgumentException("Not an enum", nameof(xenum));

			var vkEnum = new EnumMemberDefinition();

			var xattributes = xenum.Attributes();
			if (xattributes.Count() != 0)
			{
				foreach (var xattrib in xattributes)
				{
					switch (xattrib.Name.ToString())
					{
						case "name":
							vkEnum.Name = vkEnum.SpecName = xattrib.Value;
							break;
						case "bitpos":
						case "value":
							vkEnum.Value = xattrib.Value;
							break;
						case "comment":
							vkEnum.Comment = xattrib.Value;
							break;
						default: throw new NotImplementedException(xattrib.Name.ToString());
					}
				}
			}

			if (string.IsNullOrEmpty(vkEnum.Name) || string.IsNullOrEmpty(vkEnum.Value))
				throw new InvalidOperationException("Enum collection does not have proper `<name>` or `<value>` or `<bitpos>` element");

			return vkEnum;
		}

		public override void MapTypes()
		{
			var xTypes = VulkanSpec.SpecTree.Element("types").Elements("type");

			var bitmaskTypes = xTypes
										.Where(TypeBitmaskFilter)
										.ToList();

			var emptyBitmaskNames = bitmaskTypes
					.Where(x => x.Attribute("requires") == null)
					.Select(x => x.Element("name").Value)
					.ToList();

			var emptyBitmasks = emptyBitmaskNames.Select(GenerateEmptyBitmask);

			var xenums = VulkanSpec.SpecTree.Elements("enums");
			var enums = xenums.Select(ReadEnum);

			// Add the empty bitmasks generated above
			enums = enums.Concat(emptyBitmasks);

			foreach (var vkEnum in enums)
			{
				VulkanSpec.AllTypes.Add(vkEnum.Name, vkEnum);
			}
		}

		public override void Rewrite()
		{
			foreach (var vkEnum in VulkanSpec.Enums)
			{
				if (vkEnum.Name.StartsWith("Vk"))
					vkEnum.Name = vkEnum.Name.Remove(0, 2); // trim `Vk`

				var expand = vkEnum.Expand;
				// Add one to the length to deal with the trailing underscore. ie: {VK_EXPAND_NAME_}VALUE_NAME
				var expandLen = (!string.IsNullOrEmpty(expand)) ? expand.Length + 1 : 0;
				foreach (var vkEnumValue in vkEnum.Members)
				{
					var name = vkEnumValue.Name;
					if (!string.IsNullOrEmpty(expand) && name.StartsWith(expand))
						name = name.Substring(expandLen, name.Length - expandLen);

					if (name.StartsWith("VK_"))
						name = name.Substring(3, name.Length - 3);

					vkEnumValue.Name = name;
				}

				// After the we've renamed all the enum values, check if there are any that
				// begin with a number (invalid in C#) and fix it.
				if (vkEnum.Members.Any(x => Regex.IsMatch(x.Name, "^[0-9]")))
				{
					foreach (var vkEnumValue in vkEnum.Members)
					{
						var name = vkEnumValue.Name;
						name = vkEnum.Name + name;
						vkEnumValue.Name = name;
					}
				}
			}
		}

		public override void Build()
		{
		}

		public override void Create()
		{
			var validEnums = VulkanSpec.Enums.Where(x => x.Name != "API Constants");

			foreach (var enumDefinition in validEnums)
			{
				if (enumDefinition.Members.Count > 0)
				{
					var output = new OutputDefinition<EnumDefinition>() { FileName = enumDefinition.Name };
					output.TargetSolution = TargetSolution;
					output.AddNamespace(TargetNamespace);
					output.TemplateName = "EnumTemplate";
					output.OutputDirectory = "Enums";

					output.TypeDefinitions.Add(enumDefinition);
										
					if (enumDefinition.HasFlags)
					{
						output.AddStandardUsingDirective("System");
					}

					Generator.GenerateCodeFile(output);
					NumberCreated++;
				}
				else
				{
					// Do not make an enum for a type with no values...
				}
			}
		}
	}
}
